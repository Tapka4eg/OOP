#include <iostream>
#include <string>
#include "ILoggable.h"
#include "IShuffle.h"
#include "Summator.h"
#include "Multiplier.h"
#include "CustomExpressionEvaluator.h"

/*Написать в ООП-стиле код программы, позволяющей работать с арифметическими выражениями разного вида, оперирующими вещественными числами: вычислять
результат выражения, выводить запись выражения на консоль и в файл лога.
Например, для вычисления выражений вида (10+4+2+3+7+1) и (1+2.5) будет использоваться класс Summator, выражений вида (2*3*7*1) – класс Multiplier, и т.д.
В коде необходимо отразить следующее:
1) Создать интерфейс ILoggable с 2 методами (функционал логирования):
Запись лога всего выражения на консоль:
void logToScreen()
Добавление записи лога всего выражения в файл лога:
void logToFile(const std::string& filename).
2) Создать абстрактный класс ExpressionEvaluator, реализующий интерфейс ILoggable и предоставляющий чисто виртуальный метод double calculate() для
вычисления результата произвольного выражения. Количество операндов должно храниться в отдельном члене класса. Сами операнды х1,х2,х3 и т.д. должны
храниться в члене данного класса – массиве, в куче (динамической памяти).
3) Класс ExpressionEvaluator должен предоставлять два конструктора и виртуальный деструктор. В конструкторе без параметров выделять память под 20
операндов и инициализировать их нулями, в конструкторе с параметром n – выделять память под n элементов и инициализировать нулями. Также необходимо
реализовать 2 метода, позволяющие присвоить операндам конкретные значения:
Присвоить значение value одному операнду на позиции pos:
void setOperand(size_t pos, double value)
Заполнить сразу группу из n операндов массивом значений ops:
void setOperands(double ops[], size_t n)
4) В деструкторе должна освобождаться память, выделенная в конструкторе.
5) Создать два подкласса класса ExpressionEvaluator, работающих со стандартными выражениями, в соответствии с вариантом, из четырех возможных:
Summator – сумма всех операндов (х1 + х2 + х3 + х4 + ...)
Subtractor – разность всех операндов (х1 – х2 – х3 – х4 – ...)
Multiplier – произведение всех операндов (х1 * х2 * х3 * х4 * ...)
Divisor – частное всех операндов (х1/х2/х3/х4/...), но если хоть один
 операнд равен 0, то результату выражения присвоить также 0.
6) Создать подкласс CustomExpressionEvaluator, работающий со специфическими
выражениями, вид которых приведен в варианте.
7) Подклассы ExpressionEvaluator, для которых порядок следования операндов важен, должны также реализовывать интерфейс IShuffle. Данный интерфейс
объявляет 2 перегруженных метода (функционал перемешивания операндов):
Произвольно перемешать операнды:
void shuffle()
Перемешать операнды, находящиеся на позициях i и j:
void shuffle(size_t i, size_t j)
В функции main() необходимо продемонстрировать работу созданных классов:
1) Создать массив из трех указателей на класс обработки арифметических выражений.
2) В соответствии с вариантом, создать в куче три объекта конкретных подклассов обработки арифметических выражений и установить на них указатели; присвоить
их операндам значения двумя способами (поэлементным и групповым).
3) Продемонстрировать полиморфизм: организовать проход в цикле по указателям и вывести лог выражения на консоль и в файл (в консоли отобразить еще и сам результат выражения).
4) Организовать цикл по указателям, в теле которого средствами С++ проверить, реализует ли текущий объект интерфейс IShuffle. Если да, то вызвать один из
методов shuffle() этого объекта и отобразить на экране запись выражения после перемешивания операндов, а также вычислить и отобразить результат нового выражения.

Вариант 4:
Вид выражения CustomExpression: result = x1 + 2*x2 + 3*x3 + 4*x4 + ...
Порядок создания и инициализации объектов подклассов:
CustomExpressionEvaluator: 4 операнда, присвоить поэлементно 50, 40, -10, -2.
Multiplier: 4 операнда, присвоить группой -0.5, -8, 1.5, 16.
Summator: 6 операндов, присвоить группой 2.6,-8.1, 13.2, 1.5, 3.4, -4.
Метод shuffle() – отсортировать все операнды в порядке убывания.
Метод shuffle(size_t i, size_t j) – отсортировать все операнды между i-ым и j-ым.
Формат вывода:
4 operands :
50 + 2*40 + 3*(-10) + (-2)
-> 98
*/
int main()
{
    ExpressionEvaluator* eval_op[3];
	eval_op[0] = new Multiplier(4);
	double* ops_mult = new double[4]{ -0.5, -8, 1.5, 16 };
	eval_op[0]->setOperands(ops_mult, 4);

	eval_op[1] = new Summator(6);
	double* ops_sum = new double[6]{ 2.6, -8.1, 13.2, 1.5, 3.4, -4 };
	eval_op[1]->setOperands(ops_sum, 6);

	eval_op[2] = new CustomExpressionEvaluator(4);
	double* ops_custom = new double[4]{ 50, 40, -10, -2 };

	for (int i = 0; i < 4; i++)
	{
		eval_op[2]->setOperand(i, ops_custom[i]);
	}
		
	for (int i = 0; i < 3; i++)
	{
		eval_op[i]->logToScreen();
		eval_op[i]->logToFile("log.txt");
	}

	for (int i = 0; i < 3; i++)
	{
		IShuffle* is = dynamic_cast<IShuffle*>(eval_op[i]);
		if (is)
		{
			is->shuffle();
			eval_op[i]->logToScreen();
		}
	}

	for (int i = 0; i < 3; i++)
	{
		delete eval_op[i];
	}

	return 0;
}
